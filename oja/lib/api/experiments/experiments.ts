/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * A/B Testing Server for Pricing Experiments
 * Server for conducting A/B testing experiments on pricing strategies using Paid.ai integration.

This server provides endpoints for:
- Assigning users to experiment variants
- Tracking pricing page views and conversions
- Processing Paid.ai webhook events
- Analyzing experiment results

**Architecture**: The system uses deterministic SHA-256 hashing to ensure consistent user-to-variant mapping,
emits signals to Paid.ai's Signals API for event tracking, and provides real-time analytics.

 * OpenAPI spec version: 1.0.0
 */
import type {
  ConversionResponse,
  Error,
  ExperimentDefinition,
  ExperimentResults,
  GetApiExperimentsExperimentIdDefinitionParams,
  GetApiExperimentsExperimentIdPricingParams,
  GetApiPricingParams,
  PostApiConvertBody,
  PostApiExperimentsExperimentIdConvertBody,
  PricingResponse
} from '.././schemas';

import { customFetch } from '.././custom-fetch';

/**
 * Tenant-aware pricing endpoint. Assigns a user to an A/B test variant and returns 
the corresponding pricing. Uses the tenant's mode (BYOK or Managed) to determine
which Paid.ai API key to use for signal emission.

 * @summary Get pricing with variant assignment
 */
export type getApiExperimentsExperimentIdPricingResponse200 = {
  data: PricingResponse
  status: 200
}

export type getApiExperimentsExperimentIdPricingResponse400 = {
  data: Error
  status: 400
}

export type getApiExperimentsExperimentIdPricingResponse404 = {
  data: Error
  status: 404
}

export type getApiExperimentsExperimentIdPricingResponse500 = {
  data: Error
  status: 500
}
    
export type getApiExperimentsExperimentIdPricingResponseSuccess = (getApiExperimentsExperimentIdPricingResponse200) & {
  headers: Headers;
};
export type getApiExperimentsExperimentIdPricingResponseError = (getApiExperimentsExperimentIdPricingResponse400 | getApiExperimentsExperimentIdPricingResponse404 | getApiExperimentsExperimentIdPricingResponse500) & {
  headers: Headers;
};

export type getApiExperimentsExperimentIdPricingResponse = (getApiExperimentsExperimentIdPricingResponseSuccess | getApiExperimentsExperimentIdPricingResponseError)

export const getGetApiExperimentsExperimentIdPricingUrl = (experimentId: string,
    params: GetApiExperimentsExperimentIdPricingParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/api/experiments/${experimentId}/pricing?${stringifiedParams}` : `/api/api/experiments/${experimentId}/pricing`
}

export const getApiExperimentsExperimentIdPricing = async (experimentId: string,
    params: GetApiExperimentsExperimentIdPricingParams, options?: RequestInit): Promise<getApiExperimentsExperimentIdPricingResponse> => {
  
  return customFetch<getApiExperimentsExperimentIdPricingResponse>(getGetApiExperimentsExperimentIdPricingUrl(experimentId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Records a conversion event for a user in an experiment. Uses tenant context
to determine the correct Paid.ai API key for signal emission.

 * @summary Record conversion for experiment
 */
export type postApiExperimentsExperimentIdConvertResponse200 = {
  data: ConversionResponse
  status: 200
}

export type postApiExperimentsExperimentIdConvertResponse400 = {
  data: Error
  status: 400
}

export type postApiExperimentsExperimentIdConvertResponse404 = {
  data: Error
  status: 404
}

export type postApiExperimentsExperimentIdConvertResponse500 = {
  data: Error
  status: 500
}
    
export type postApiExperimentsExperimentIdConvertResponseSuccess = (postApiExperimentsExperimentIdConvertResponse200) & {
  headers: Headers;
};
export type postApiExperimentsExperimentIdConvertResponseError = (postApiExperimentsExperimentIdConvertResponse400 | postApiExperimentsExperimentIdConvertResponse404 | postApiExperimentsExperimentIdConvertResponse500) & {
  headers: Headers;
};

export type postApiExperimentsExperimentIdConvertResponse = (postApiExperimentsExperimentIdConvertResponseSuccess | postApiExperimentsExperimentIdConvertResponseError)

export const getPostApiExperimentsExperimentIdConvertUrl = (experimentId: string,) => {


  

  return `/api/api/experiments/${experimentId}/convert`
}

export const postApiExperimentsExperimentIdConvert = async (experimentId: string,
    postApiExperimentsExperimentIdConvertBody: PostApiExperimentsExperimentIdConvertBody, options?: RequestInit): Promise<postApiExperimentsExperimentIdConvertResponse> => {
  
  return customFetch<postApiExperimentsExperimentIdConvertResponse>(getPostApiExperimentsExperimentIdConvertUrl(experimentId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postApiExperimentsExperimentIdConvertBody,)
  }
);}


/**
 * Assigns a user to an A/B test variant (control or experiment) and returns the corresponding pricing.
The assignment is deterministic based on userId and experimentId, ensuring consistency across sessions.
Also emits a signal to Paid.ai tracking the pricing view event.

 * @summary Get pricing with variant assignment
 */
export type getApiPricingResponse200 = {
  data: PricingResponse
  status: 200
}

export type getApiPricingResponse400 = {
  data: Error
  status: 400
}

export type getApiPricingResponse500 = {
  data: Error
  status: 500
}
    
export type getApiPricingResponseSuccess = (getApiPricingResponse200) & {
  headers: Headers;
};
export type getApiPricingResponseError = (getApiPricingResponse400 | getApiPricingResponse500) & {
  headers: Headers;
};

export type getApiPricingResponse = (getApiPricingResponseSuccess | getApiPricingResponseError)

export const getGetApiPricingUrl = (params?: GetApiPricingParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/api/pricing?${stringifiedParams}` : `/api/api/pricing`
}

export const getApiPricing = async (params?: GetApiPricingParams, options?: RequestInit): Promise<getApiPricingResponse> => {
  
  return customFetch<getApiPricingResponse>(getGetApiPricingUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Records a conversion (subscription/purchase) for a user in an experiment.
The user must have been previously assigned to a variant via the /api/pricing endpoint.
Emits a conversion signal to Paid.ai for tracking.

 * @summary Track a conversion event
 */
export type postApiConvertResponse200 = {
  data: ConversionResponse
  status: 200
}

export type postApiConvertResponse400 = {
  data: Error
  status: 400
}

export type postApiConvertResponse404 = {
  data: Error
  status: 404
}

export type postApiConvertResponse500 = {
  data: Error
  status: 500
}
    
export type postApiConvertResponseSuccess = (postApiConvertResponse200) & {
  headers: Headers;
};
export type postApiConvertResponseError = (postApiConvertResponse400 | postApiConvertResponse404 | postApiConvertResponse500) & {
  headers: Headers;
};

export type postApiConvertResponse = (postApiConvertResponseSuccess | postApiConvertResponseError)

export const getPostApiConvertUrl = () => {


  

  return `/api/api/convert`
}

export const postApiConvert = async (postApiConvertBody: PostApiConvertBody, options?: RequestInit): Promise<postApiConvertResponse> => {
  
  return customFetch<postApiConvertResponse>(getPostApiConvertUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postApiConvertBody,)
  }
);}


/**
 * Retrieves the experiment configuration including all variants with their prices
and weights. This endpoint is used by jale to read experiment variants for
optimization calculations.

 * @summary Get experiment definition and variants
 */
export type getApiExperimentsExperimentIdDefinitionResponse200 = {
  data: ExperimentDefinition
  status: 200
}

export type getApiExperimentsExperimentIdDefinitionResponse404 = {
  data: Error
  status: 404
}

export type getApiExperimentsExperimentIdDefinitionResponse500 = {
  data: Error
  status: 500
}
    
export type getApiExperimentsExperimentIdDefinitionResponseSuccess = (getApiExperimentsExperimentIdDefinitionResponse200) & {
  headers: Headers;
};
export type getApiExperimentsExperimentIdDefinitionResponseError = (getApiExperimentsExperimentIdDefinitionResponse404 | getApiExperimentsExperimentIdDefinitionResponse500) & {
  headers: Headers;
};

export type getApiExperimentsExperimentIdDefinitionResponse = (getApiExperimentsExperimentIdDefinitionResponseSuccess | getApiExperimentsExperimentIdDefinitionResponseError)

export const getGetApiExperimentsExperimentIdDefinitionUrl = (experimentId: string,
    params?: GetApiExperimentsExperimentIdDefinitionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/api/experiments/${experimentId}/definition?${stringifiedParams}` : `/api/api/experiments/${experimentId}/definition`
}

export const getApiExperimentsExperimentIdDefinition = async (experimentId: string,
    params?: GetApiExperimentsExperimentIdDefinitionParams, options?: RequestInit): Promise<getApiExperimentsExperimentIdDefinitionResponse> => {
  
  return customFetch<getApiExperimentsExperimentIdDefinitionResponse>(getGetApiExperimentsExperimentIdDefinitionUrl(experimentId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Retrieves comprehensive analytics and statistics for an A/B test experiment,
including view counts, conversion rates, revenue metrics, and ARPU by variant.

 * @summary Get experiment results
 */
export type getApiExperimentsExperimentIdResultsResponse200 = {
  data: ExperimentResults
  status: 200
}

export type getApiExperimentsExperimentIdResultsResponse400 = {
  data: Error
  status: 400
}

export type getApiExperimentsExperimentIdResultsResponse500 = {
  data: Error
  status: 500
}
    
export type getApiExperimentsExperimentIdResultsResponseSuccess = (getApiExperimentsExperimentIdResultsResponse200) & {
  headers: Headers;
};
export type getApiExperimentsExperimentIdResultsResponseError = (getApiExperimentsExperimentIdResultsResponse400 | getApiExperimentsExperimentIdResultsResponse500) & {
  headers: Headers;
};

export type getApiExperimentsExperimentIdResultsResponse = (getApiExperimentsExperimentIdResultsResponseSuccess | getApiExperimentsExperimentIdResultsResponseError)

export const getGetApiExperimentsExperimentIdResultsUrl = (experimentId: string,) => {


  

  return `/api/api/experiments/${experimentId}/results`
}

export const getApiExperimentsExperimentIdResults = async (experimentId: string, options?: RequestInit): Promise<getApiExperimentsExperimentIdResultsResponse> => {
  
  return customFetch<getApiExperimentsExperimentIdResultsResponse>(getGetApiExperimentsExperimentIdResultsUrl(experimentId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


